document.addEventListener('DOMContentLoaded', function() { const map = L.map('map').setView([52.232, 21.006], 16); L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>', subdomains: 'abcd', minZoom: 7, maxZoom: 19 }).addTo(map); let currentRouteLayer = null; let currentPointsLayers = []; let userLocationMarker = null; function parseGPX(gpxString) { try { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(gpxString, "text/xml"); const parseError = xmlDoc.querySelector("parsererror"); if (parseError) { throw new Error("Nie można sparsować pliku GPX"); } const trackPoints = Array.from(xmlDoc.querySelectorAll("trkpt")); if (trackPoints.length === 0) { throw new Error("Brak punktów trasy w pliku GPX"); } const points = trackPoints.map(point => { const lat = parseFloat(point.getAttribute("lat")); const lon = parseFloat(point.getAttribute("lon")); if (isNaN(lat) || isNaN(lon)) { throw new Error("Nieprawidłowe współrzędne w pliku GPX"); } const ele = point.querySelector("ele") ? parseFloat(point.querySelector("ele").textContent) : null; const time = point.querySelector("time") ? new Date(point.querySelector("time").textContent) : null; const extensions = point.querySelector("extensions"); let highway = null; let surface = null; let maxspeed = null; let junction = null; let reversedirection = null; if (extensions) { const extPath = "gpxtpx\\:Extensions, Extensions"; const ext = extensions.querySelector(extPath); if (ext) { highway = ext.querySelector("highway") ? ext.querySelector("highway").textContent : null; surface = ext.querySelector("surface") ? ext.querySelector("surface").textContent : null; maxspeed = ext.querySelector("maxspeed") ? ext.querySelector("maxspeed").textContent : null; junction = ext.querySelector("junction") ? ext.querySelector("junction").textContent : null; reversedirection = ext.querySelector("reversedirection") ? ext.querySelector("reversedirection").textContent : null; } } return { lat, lon, ele, time, highway, surface, maxspeed, junction, reversedirection }; }); return points; } catch (error) { alert(`Błąd podczas parsowania GPX: ${error.message}`); return null; } } function calculateRouteLength(points) { let length = 0; for (let i = 0; i < points.length - 1; i++) { const from = turf.point([points[i].lon, points[i].lat]); const to = turf.point([points[i + 1].lon, points[i + 1].lat]); length += turf.distance(from, to); } return length; } function formatDuration(milliseconds) { const seconds = Math.floor(milliseconds / 1000); const minutes = Math.floor(seconds / 60); const hours = Math.floor(minutes / 60); const days = Math.floor(hours / 24); const remainingHours = hours % 24; const remainingMinutes = minutes % 60; const remainingSeconds = seconds % 60; if (days > 0) { return `${days}:${remainingHours.toString().padStart(2, '0')}:${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`; } else { return `${remainingHours.toString().padStart(2, '0')}:${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`; } } function displayRoute(gpxString) { if (currentRouteLayer) { map.removeLayer(currentRouteLayer); } currentPointsLayers.forEach(layer => { map.removeLayer(layer); }); currentPointsLayers = []; const routePoints = parseGPX(gpxString); if (!routePoints) { return; } const routeCoordinates = routePoints.map(point => [point.lat, point.lon]); currentRouteLayer = L.polyline(routeCoordinates, { color: '#2196f3', weight: 3, opacity: 0.7 }).addTo(map); routePoints.forEach((point, index) => { let pointColor = 'transparent'; let pointSize = 6; if (index === 0) { pointColor = '#4caf50'; pointSize = 9; } else if (index === routePoints.length - 1) { pointColor = '#9e9e9e'; pointSize = 9; } const pointMarker = L.circleMarker([point.lat, point.lon], { radius: pointSize / 2, fillColor: pointColor, color: pointColor, weight: 1, opacity: 0.8, fillOpacity: 0.4 }).addTo(map); pointMarker.on('click', function() { displayPointInfo(point); }); currentPointsLayers.push(pointMarker); }); displayRouteInfo(routePoints); } function displayRouteInfo(points) { const routeLength = calculateRouteLength(points); let infoHTML = `<div class="info-item"><span>Długość trasy:</span> <span>${routeLength.toLocaleString(undefined, { maximumFractionDigits: 2 })} km</span></div>`; const startTime = points[0].time; const endTime = points[points.length - 1].time; if (startTime && endTime) { const duration = endTime - startTime; const formattedDuration = formatDuration(duration); const averageSpeed = Number(routeLength / (duration / 1000 / 60 / 60)); const startTimeFormatted = startTime.toLocaleString(); const endTimeFormatted = endTime.toLocaleString(); infoHTML += ` <div class="info-item"><span>Czas rozpoczęcia:</span> <span>${startTimeFormatted}</span></div> <div class="info-item"><span>Czas zakończenia:</span> <span>${endTimeFormatted}</span></div> <div class="info-item"><span>Czas trwania:</span> <span>${formattedDuration}</span></div> <div class="info-item"><span>Średnia prędkość:</span> <span>${averageSpeed.toLocaleString(undefined, { maximumFractionDigits: 2 })} km/h</span></div> `; } document.querySelector("#route-info .info-content").innerHTML = infoHTML; } function displayPointInfo(point) { let infoHTML = `<div class="point-info">`; infoHTML += `<h3>Punkt trasy</h3>`; infoHTML += `<div class="point-info-item">Współrzędne: ${point.lat.toFixed(5)}, ${point.lon.toFixed(5)}</div>`; if (point.ele !== null) { infoHTML += `<div class="point-info-item">Wysokość: ${point.ele.toLocaleString(undefined, { maximumFractionDigits: 3 })} m n.p.m.</div>`; } if (point.time !== null) { infoHTML += `<div class="point-info-item">Czas: ${point.time.toLocaleString()}</div>`; } if (point.highway !== null) { infoHTML += `<div class="point-info-item">Typ drogi: ${point.highway}</div>`; } if (point.surface !== null) { infoHTML += `<div class="point-info-item">Nawierzchnia: ${point.surface}</div>`; } if (point.maxspeed !== null) { infoHTML += `<div class="point-info-item">Maksymalna prędkość: ${point.maxspeed} km/h</div>`; } if (point.junction !== null) { infoHTML += `<div class="point-info-item">Skrzyżowanie: ${point.junction}</div>`; } if (point.reversedirection !== null) { infoHTML += `<div class="point-info-item">Odwrotny kierunek: ${point.reversedirection}</div>`; } infoHTML += `</div>`; document.querySelector("#point-info-container .point-info-content").innerHTML = infoHTML; } function trackUserLocation() { if (navigator.geolocation) { navigator.geolocation.watchPosition( function(position) { const lat = position.coords.latitude; const lon = position.coords.longitude; if (userLocationMarker) { map.removeLayer(userLocationMarker); } userLocationMarker = L.circleMarker([lat, lon], { radius: 8, fillColor: '#2196f3', color: '#ffffff', weight: 2, opacity: 1, fillOpacity: 0.8, className: 'user-location' }).addTo(map); }, function(error) { console.error("Błąd geolokalizacji:", error.message); }, { enableHighAccuracy: true, maximumAge: 30000, timeout: 27000 } ); } else { console.error("Geolokalizacja nie jest wspierana przez tę przeglądarkę."); } } document.getElementById('draw-route').addEventListener('click', function() { const gpxText = document.getElementById('gpx-text').value.trim(); if (!gpxText) { alert("Proszę wkleić zawartość pliku GPX"); return; } displayRoute(gpxText); }); trackUserLocation(); });